# 8강 - 통신
## 소켓통신
Socket이란 운영체제가 가지고 있는 것이다.

A라는 서버와 B라는 클라이언트가 메세지를 교환하기 위해 소켓을 이용한다.

A와 B가 메세지를 교환하기 위해 A가 소켓을 오픈한다. 통신을 위해 이 오픈한 소켓의 포트(port) 번호가 필요하다.

이 포트번호를 **5000번**이라고 가정해보자.  

![a](https://user-images.githubusercontent.com/68761119/145152372-b75014f6-eef4-4046-b3e0-8ea887c0d332.png)

이때, 새로운 클라이언트 C가 들어온다.

하지만 이미 B가 5000번 포트와 연결되어 통신하고 있기 때문에 C는 5000번 포트를 사용할 수 없다.
 
이런 문제를 해결하기 위해 **최초**의 5000번 포트는 연결의 용도로만 이용한다.

연결이 되는 순간 새로운 소켓을 만들어서 클라이언트들과 연결한다. 이때 포트는 랜덤으로 부여된다.

B가 A와 연결을 할 때 5000번 포트를 이용해 연결을 시도하고 연결이 되는 순간 5000번 소켓과의 연결은 끊어지고 새로운 소켓인 5001번 소켓과 연결이 된다.

![s](https://user-images.githubusercontent.com/68761119/145152474-fbb08957-1b49-4730-aaaa-ded7f9f9f005.png)

**이때 문제가 하나 발생한다.**

B와 5001번 소켓이 계속해서 통신을 하게 되면 모든 cpu자원을 B와 5001번 소켓을 위해 사용되기 때문에 5000번 소켓이 작동을 못하게 된다.

5000번 소켓은 새로운 클라이언트의 연결을 받아야 하는데 새로운 연결을 받지를 못한다


그래서 소켓을 만들 때 새로운 **스레드**를 생성해서 이용한다.

B는 포트번호 5000번 소켓과 연결을 시도한다.
연결이 성공하면 새로운 스레드로 5001번 소켓이 생성이 되고 B와 연결을 유지한다.  

C 역시 5000번 소켓과 연결을 시도한다.
연결이 성공하면 새로운 스레드로 5002번 소켓이 생성이 되고 C와 연결을 유지한다.  

이 과정이 계속 이루어지는 것이 소켓 통신이다

cpu를 time splice로 쪼개서 각각의 스레드들이 동시에 작동하는 것처럼 보이게 한다.

![xx](https://user-images.githubusercontent.com/68761119/145152512-8ccbfdbf-76b1-403a-a6cf-5276b83264d0.png)

소켓 통신의 장점은 연결이 **Stateful**하다는 것이다. 지속적으로 데이터를 주고받을 때 매우 유리하지만 부하가 크다.
 

## HTTP 통신
HTTP통신은 **Stateless** 방식을 사용한다.

HTTP통신은 소켓통신과 다르게 새로운 스레드를 만드는것이 아니라 클라이언트의 요청에 맞는 응답을 보내고 연결을 끊어버린다.

연결을 끊어버리기 때문에 클라이언트의 요청마다 새로 연결을 해야한다. (3-way-handshake)  

![ax](https://user-images.githubusercontent.com/68761119/145152910-761e3c0e-4330-491d-84d6-a5d07469a3db.png)


[사진출처](https://sic-dev.tistory.com/88?category=938022)